/*
 * X509CertificateClient.java
 *
 * Created on May 20, 2010, 7:08:14 AM
 *
 * Description: Provides a client for the X.509 certificate server.
 *
 * Copyright (C) May 20, 2010, Stephen L. Reed.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program;
 * if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package org.texai.x509certificateserver.util;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.PublicKey;
import java.security.cert.CertPath;
import java.util.concurrent.Executors;
import net.jcip.annotations.NotThreadSafe;
import org.apache.log4j.Logger;
import org.jboss.netty.bootstrap.ClientBootstrap;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBuffers;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ExceptionEvent;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
import org.jboss.netty.handler.codec.http.HttpHeaders;
import org.jboss.netty.handler.codec.http.HttpMethod;
import org.jboss.netty.handler.codec.http.HttpRequest;
import org.jboss.netty.handler.codec.http.HttpResponse;
import org.jboss.netty.handler.codec.http.HttpVersion;
import org.texai.network.netty.handler.AbstractHTTPResponseHandler;
import org.texai.network.netty.pipeline.HTTPClientPipelineFactory;
import org.texai.util.Base64Coder;
import org.texai.util.ByteUtils;
import org.texai.util.EnvironmentUtils;
import org.texai.util.NetworkUtils;
import org.texai.util.StringUtils;
import org.texai.util.TexaiException;
import org.texai.x509.X509SecurityInfo;

/** Provides a client for the X.509 certificate server.
 *
 * @author reed
 */
@NotThreadSafe
public final class X509CertificateClient extends AbstractHTTPResponseHandler {

  /** the logger */
  private static final Logger LOGGER = Logger.getLogger(X509CertificateClient.class);
  /** the server port */
  private static final int SERVER_PORT = 443;
  /** the lock that allows the client to resume when the response is processed */
  private final Object clientResume_lock = new Object();
  /** the obtained certificate path */
  private CertPath certPath;


  /** Creates a new X509CertificateClient instance. */
  public X509CertificateClient() {
  }

  /** Obtains a certificate-signing X.509 certificate path from the server.
   *
   * @param publicKey the public key generated by the client
   * @param x509SecurityInfo the client's X.509 security info that allows it to communicate with the server
   * @return a certificate-signing X.509 certificate path
   */
  @SuppressWarnings("ThrowableResultIgnored")
  public CertPath getIssuingCertificatePath(
          final PublicKey publicKey,
          final X509SecurityInfo x509SecurityInfo) {
    //Preconditions
    assert publicKey != null : "publicKey must not be null";

    final String host = EnvironmentUtils.certificateServerHost();
    LOGGER.info("certificate server host: " + host);
    assert NetworkUtils.isHostAvailable(host, SERVER_PORT);

    final ClientBootstrap clientBootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(
            Executors.newCachedThreadPool(),
            Executors.newCachedThreadPool()));

    // configure the client pipeline
    final ChannelPipeline channelPipeline = HTTPClientPipelineFactory.getPipeline(
            this,
            x509SecurityInfo);
    clientBootstrap.setPipeline(channelPipeline);
    LOGGER.debug("client pipeline: " + channelPipeline.toString());

    // start the connection attempt
    SocketAddress socketAddress = new InetSocketAddress(host, SERVER_PORT);
    ChannelFuture channelFuture = clientBootstrap.connect(socketAddress);

    // wait until the connection attempt succeeds or fails
    final Channel channel = channelFuture.awaitUninterruptibly().getChannel();
    if (!channelFuture.isSuccess()) {
      LOGGER.warn(StringUtils.getStackTraceAsString(channelFuture.getCause()));
      throw new TexaiException(channelFuture.getCause());
    }
    LOGGER.debug(Thread.currentThread().getName() + " connected to " + socketAddress);

    URI uri = null;
    HttpRequest httpRequest;

    // send the certificate request
    try {
      uri = new URI("https://" + host + ":" + SERVER_PORT + "/CA/certificate-request");
    } catch (URISyntaxException ex) {
      throw new TexaiException(ex);
    }
    httpRequest = new DefaultHttpRequest(
            HttpVersion.HTTP_1_1,
            HttpMethod.POST,
            uri.toASCIIString());
    httpRequest.setHeader(HttpHeaders.Names.HOST, host);
    httpRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, "application/octet-stream");
    httpRequest.setHeader(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING, HttpHeaders.Values.BINARY);
    httpRequest.setHeader(HttpHeaders.Names.USER_AGENT, Thread.currentThread().getName());

    final byte[] serializedClientPublicKey = ByteUtils.serialize(publicKey);
    final char[] base64SerializedClientPublicKey = Base64Coder.encode(serializedClientPublicKey);
    LOGGER.debug("base64SerializedClientPublicKey length: " + base64SerializedClientPublicKey.length);
    final String base64SerializedClientPublicKeyString = new String(base64SerializedClientPublicKey);
    final ChannelBuffer channelBuffer = ChannelBuffers.copiedBuffer(base64SerializedClientPublicKeyString.getBytes());
    LOGGER.debug("content: " + new String(channelBuffer.array()));
    LOGGER.debug("content length: " + channelBuffer.array().length);
    httpRequest.setContent(channelBuffer);
    httpRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(channelBuffer.array().length));
    channel.write(httpRequest);

    // wait for the request message to be sent
    channelFuture.awaitUninterruptibly();
    if (!channelFuture.isSuccess()) {
      LOGGER.warn(StringUtils.getStackTraceAsString(channelFuture.getCause()));
      throw new TexaiException(channelFuture.getCause());
    }

    // the message response handler will signal this thread when the test exchange is completed
    LOGGER.debug(Thread.currentThread().getName() + " client waiting for server to process the request");
    synchronized (clientResume_lock) {
      try {
        clientResume_lock.wait();
      } catch (InterruptedException ex) {
      }
    }
    LOGGER.debug("client releasing HTTP resources");
    channel.close();
    clientBootstrap.releaseExternalResources();

    //Postconditions
    assert certPath != null;

    return certPath;
  }

  /** Receives a message object from a remote peer.
   *
   * @param channelHandlerContext the channel handler context
   * @param messageEvent the message event
   */
  @Override
  public void messageReceived(
          final ChannelHandlerContext channelHandlerContext,
          final MessageEvent messageEvent) {
    //Preconditions
    assert channelHandlerContext != null : "channelHandlerContext must not be null";
    assert messageEvent != null : "messageEvent must not be null";

    LOGGER.debug("client received messageEvent: " + messageEvent);
    final HttpResponse httpResponse = (HttpResponse) messageEvent.getMessage();

    LOGGER.debug("STATUS: " + httpResponse.getStatus());
    LOGGER.debug("VERSION: " + httpResponse.getProtocolVersion());
    LOGGER.debug("");

    if (!httpResponse.getHeaderNames().isEmpty()) {
      for (final String name : httpResponse.getHeaderNames()) {
        for (final String value : httpResponse.getHeaders(name)) {
          LOGGER.debug("HEADER: " + name + " = " + value);
        }
      }
      LOGGER.debug("");
    }

    final byte[] contentBytes = httpResponse.getContent().array();
    assert contentBytes != null;
    assert contentBytes.length > 0;
    certPath = (CertPath) ByteUtils.deserialize(contentBytes);
    LOGGER.debug("certPath: " + certPath);

    // signal the client thread to resume
    synchronized (clientResume_lock) {
      clientResume_lock.notifyAll();
    }
  }

  /** Handles a caught exception.
   *
   * @param channelHandlerContext the channel handler event
   * @param exceptionEvent the exception event
   */
  @Override
  public void exceptionCaught(
          final ChannelHandlerContext channelHandlerContext,
          final ExceptionEvent exceptionEvent) {
    //Preconditions
    assert channelHandlerContext != null : "channelHandlerContext must not be null";
    assert exceptionEvent != null : "exceptionEvent must not be null";

    LOGGER.error("exceptionEvent: " + exceptionEvent);
  }
}
